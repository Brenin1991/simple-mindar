
<html>
  <head>
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <script src="https://aframe.io/releases/1.6.0/aframe.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/mind-ar@1.2.5/dist/mindar-image-aframe.prod.js"></script>
    <!-- OpenCV.js para processamento de imagem e extra√ß√£o de regi√£o -->
    <script async src="https://docs.opencv.org/4.8.0/opencv.js" onload="onOpenCvReady();" type="text/javascript"></script>
    <style>
      body {
        margin: 0;
        padding: 0;
        overflow: hidden;
      }
    </style>
  </head>
  <body>
    <a-scene 
      mindar-image="imageTargetSrc: ./targets.mind;" 
      color-space="sRGB" 
      renderer="colorManagement: true, physicallyCorrectLights" 
      vr-mode-ui="enabled: false" 
      device-orientation-permission-ui="enabled: false"
      id="ar-scene">
      <a-assets>
        <img id="card" src="https://cdn.jsdelivr.net/gh/hiukim/mind-ar-js@1.2.5/examples/image-tracking/assets/card-example/card.png" />
        <a-asset-item id="avatarModel" src="https://cdn.jsdelivr.net/gh/hiukim/mind-ar-js@1.2.5/examples/image-tracking/assets/card-example/softmind/scene.gltf"></a-asset-item>
      </a-assets>

      <a-camera position="0 0 0" look-controls="enabled: false"></a-camera>
      <a-entity mindar-image-target="targetIndex: 0" id="target-entity">
        <a-plane id="drawing-plane" position="0 0 0" height="1" width="1" rotation="0 0 0" material="transparent: true; opacity: 0"></a-plane>
        <a-gltf-model rotation="0 0 0 " position="0 0 0.1" scale="0.005 0.005 0.005" src="#avatarModel" animation="property: position; to: 0 0.1 0.1; dur: 1000; easing: easeInOutQuad; loop: true; dir: alternate">
      </a-entity>
    </a-scene>

    <script>
      // Sistema de captura e processamento de imagem do target
      let videoElement = null;
      let canvas = null;
      let ctx = null;
      let isTargetDetected = false;
      let textureCreated = false;
      let opencvReady = false;
      let mindarSystem = null;

      // Aguarda o carregamento da cena
      const scene = document.querySelector('#ar-scene');
      const targetEntity = document.querySelector('#target-entity');
      const drawingPlane = document.querySelector('#drawing-plane');

      // Callback quando OpenCV est√° pronto
      function onOpenCvReady() {
        opencvReady = true;
        console.log('‚úÖ OpenCV.js carregado e pronto!');
      }

      // Fun√ß√£o para encontrar o elemento de v√≠deo (fallback)
      function findVideoElement() {
        // Tenta m√∫ltiplas formas de acessar o v√≠deo
        if (!mindarSystem) {
          mindarSystem = scene.systems['mindar-image-system'];
        }
        
        if (!mindarSystem) {
          console.log('MindAR System ainda n√£o dispon√≠vel');
        }
        
        if (mindarSystem) {
          // Tenta acessar o v√≠deo de diferentes formas
          if (mindarSystem.video) {
            videoElement = mindarSystem.video;
            console.log('V√≠deo encontrado via mindarSystem.video');
          } else if (mindarSystem.el && mindarSystem.el.video) {
            videoElement = mindarSystem.el.video;
            console.log('V√≠deo encontrado via mindarSystem.el.video');
          } else if (mindarSystem.videoEl) {
            videoElement = mindarSystem.videoEl;
            console.log('V√≠deo encontrado via mindarSystem.videoEl');
          } else if (mindarSystem.videoTexture) {
            // Algumas vers√µes do MindAR exp√µem o v√≠deo como textura
            const texture = mindarSystem.videoTexture;
            if (texture && texture.image) {
              videoElement = texture.image;
              console.log('V√≠deo encontrado via videoTexture.image');
            }
          }
          
          // Tenta acessar via el (elemento da cena)
          if (!videoElement && mindarSystem.el) {
            const el = mindarSystem.el;
            if (el.components && el.components['mindar-image-system']) {
              const comp = el.components['mindar-image-system'];
              if (comp.video) {
                videoElement = comp.video;
                console.log('V√≠deo encontrado via component.video');
              }
            }
          }
        }
        
        // Tenta encontrar o v√≠deo no DOM (√∫ltima tentativa)
        if (!videoElement) {
          // Procura por todos os v√≠deos no DOM
          const videos = document.querySelectorAll('video');
          console.log('V√≠deos encontrados no DOM:', videos.length);
          
          for (let video of videos) {
            console.log('Verificando v√≠deo:', {
              readyState: video.readyState,
              videoWidth: video.videoWidth,
              videoHeight: video.videoHeight,
              src: video.src || 'N/A',
              paused: video.paused
            });
            
            // Prefere v√≠deos que est√£o prontos e t√™m dimens√µes
            if (video.readyState >= 2 && video.videoWidth > 0) {
              videoElement = video;
              console.log('‚úÖ V√≠deo encontrado no DOM e pronto!');
              break;
            } else if (video.readyState > 0) {
              // Aceita v√≠deos que est√£o carregando mas ainda n√£o prontos
              videoElement = video;
              console.log('‚úÖ V√≠deo encontrado no DOM (carregando)...');
              
              // Aguarda o v√≠deo estar pronto
              video.addEventListener('loadeddata', () => {
                console.log('V√≠deo carregado completamente');
              }, { once: true });
              break;
            }
          }
        }
        
        // Tenta acessar via THREE.js renderer
        if (!videoElement && scene.renderer) {
          const renderer = scene.renderer;
          if (renderer.domElement) {
            const video = renderer.domElement.querySelector('video');
            if (video) {
              videoElement = video;
              console.log('V√≠deo encontrado via renderer.domElement');
            }
          }
        }
        
        if (videoElement) {
          console.log('‚úÖ V√≠deo configurado:', {
            readyState: videoElement.readyState,
            videoWidth: videoElement.videoWidth,
            videoHeight: videoElement.videoHeight,
            playing: !videoElement.paused,
            src: videoElement.src || 'N/A'
          });
          setupCanvas();
          return true;
        } else {
          console.warn('‚ö†Ô∏è V√≠deo n√£o encontrado, tentando novamente...');
          return false;
        }
      }

      // Aguarda o sistema MindAR estar pronto
      function waitForMindARSystem() {
        // Tenta acessar o sistema com diferentes nomes poss√≠veis
        const systemNames = ['mindar-image-system', 'mindarSystem', 'mindar'];
        let system = null;
        
        for (let name of systemNames) {
          system = scene.systems[name];
          if (system) {
            console.log(`‚úÖ Sistema MindAR encontrado como: ${name}`);
            break;
          }
        }
        
        if (system) {
          mindarSystem = system;
          
          // Aguarda o v√≠deo estar dispon√≠vel
          const checkVideo = () => {
            // Tenta m√∫ltiplas formas de acessar o v√≠deo
            if (system.video) {
              videoElement = system.video;
              console.log('‚úÖ V√≠deo encontrado via system.video');
              setupCanvas();
              return true;
            } else if (system.videoEl) {
              videoElement = system.videoEl;
              console.log('‚úÖ V√≠deo encontrado via system.videoEl');
              setupCanvas();
              return true;
            } else if (system.el && system.el.video) {
              videoElement = system.el.video;
              console.log('‚úÖ V√≠deo encontrado via system.el.video');
              setupCanvas();
              return true;
            }
            return false;
          };
          
          // Tenta encontrar o v√≠deo imediatamente
          if (!checkVideo()) {
            // Aguarda eventos do MindAR
            if (system.el) {
              system.el.addEventListener('arReady', () => {
                console.log('AR Ready!');
                checkVideo();
              });
            }
            
            // Tenta periodicamente
            const videoCheck = setInterval(() => {
              if (checkVideo()) {
                clearInterval(videoCheck);
              }
            }, 500);
            
            // Para ap√≥s 10 segundos
            setTimeout(() => clearInterval(videoCheck), 10000);
          }
          
          return true;
        }
        
        return false;
      }

      // Aguarda a cena estar pronta
      scene.addEventListener('renderstart', () => {
        console.log('Render iniciado, aguardando MindAR...');
        // Aguarda um pouco para o sistema inicializar
        setTimeout(() => {
          if (!waitForMindARSystem()) {
            // Se n√£o encontrou, tenta encontrar o v√≠deo no DOM
            findVideoElement();
          }
        }, 2000);
      });
      
      // Tenta encontrar periodicamente o sistema e o v√≠deo
      const systemCheckInterval = setInterval(() => {
        if (!videoElement) {
          // Primeiro tenta encontrar o sistema
          if (!mindarSystem) {
            waitForMindARSystem();
          }
          
          // Depois tenta encontrar o v√≠deo diretamente no DOM
          if (!videoElement) {
            const videos = document.querySelectorAll('video');
            if (videos.length > 0) {
              for (let video of videos) {
                if (video.readyState > 0) {
                  videoElement = video;
                  console.log('‚úÖ V√≠deo encontrado no DOM durante verifica√ß√£o peri√≥dica!');
                  setupCanvas();
                  clearInterval(systemCheckInterval);
                  return;
                }
              }
            }
          }
          
          // Se encontrou o v√≠deo, para a verifica√ß√£o
          if (videoElement) {
            clearInterval(systemCheckInterval);
          }
        } else {
          clearInterval(systemCheckInterval);
        }
      }, 1000);
      
      // Para a verifica√ß√£o ap√≥s 30 segundos
      setTimeout(() => {
        clearInterval(systemCheckInterval);
        if (!videoElement) {
          console.warn('‚ö†Ô∏è N√£o foi poss√≠vel encontrar o v√≠deo ap√≥s 30 segundos');
        }
      }, 30000);

      // Configura o canvas para processamento de imagem
      function setupCanvas() {
        canvas = document.createElement('canvas');
        // Tamanho inicial, ser√° ajustado dinamicamente
        canvas.width = 640;
        canvas.height = 480;
        ctx = canvas.getContext('2d');
        // Melhora a qualidade do processamento
        ctx.imageSmoothingEnabled = true;
        ctx.imageSmoothingQuality = 'high';
      }

      // Obt√©m as coordenadas do target usando o plano AR como refer√™ncia
      function getTargetCorners() {
        try {
          // Usa o plano AR que est√° alinhado com o target
          const planeMesh = drawingPlane.getObject3D('mesh');
          if (!planeMesh) {
            console.warn('Plano AR mesh n√£o encontrado');
            return null;
          }
          
          // Atualiza a matriz do mundo
          drawingPlane.object3D.updateMatrixWorld();
          
          // Verifica se o target est√° vis√≠vel (mesmo que o plano esteja com opacity 0)
          const targetVisible = targetEntity.getAttribute('visible');
          if (targetVisible === false) {
            console.warn('Target entity n√£o est√° vis√≠vel');
            return null;
          }
          
          // Obt√©m a matriz de transforma√ß√£o do plano
          const worldMatrix = new THREE.Matrix4();
          planeMesh.updateMatrixWorld();
          worldMatrix.copy(planeMesh.matrixWorld);
          
          // Dimens√µes do plano (quadrado)
          const planeWidth = 1.0;  // Largura do plano em metros
          const planeHeight = 1.0; // Altura do plano em metros (quadrado)
          const halfWidth = planeWidth / 2;
          const halfHeight = planeHeight / 2;
          
          // Cantos do plano no espa√ßo local
          const localCorners = [
            new THREE.Vector3(-halfWidth, halfHeight, 0),  // superior esquerdo
            new THREE.Vector3(halfWidth, halfHeight, 0),    // superior direito
            new THREE.Vector3(halfWidth, -halfHeight, 0),  // inferior direito
            new THREE.Vector3(-halfWidth, -halfHeight, 0)   // inferior esquerdo
          ];
          
          // Transforma para coordenadas do mundo
          const worldCorners = localCorners.map(corner => {
            const worldCorner = corner.clone();
            worldCorner.applyMatrix4(worldMatrix);
            return worldCorner;
          });
          
          console.log('Cantos do target no espa√ßo 3D:', worldCorners);
          return worldCorners;
          
        } catch (e) {
          console.warn('Erro ao obter coordenadas do target:', e);
        }
        
        return null;
      }

      // Converte coordenadas 3D para coordenadas 2D na tela
      function project3DTo2D(corners3D, videoWidth, videoHeight) {
        if (!corners3D) return null;
        
        // Usa a c√¢mera do A-Frame para projetar
        const camera = scene.camera;
        if (!camera) {
          console.warn('C√¢mera n√£o encontrada');
          return null;
        }
        
        const corners2D = corners3D.map((corner, index) => {
          const vector = new THREE.Vector3(corner.x, corner.y, corner.z);
          
          // Projeta o ponto 3D para coordenadas da c√¢mera
          vector.project(camera);
          
          // Converte de coordenadas normalizadas (-1 a 1) para pixels
          // A c√¢mera do A-Frame usa coordenadas onde (0,0) √© o centro
          const x = (vector.x * 0.5 + 0.5) * videoWidth;
          const y = (1 - (vector.y * 0.5 + 0.5)) * videoHeight; // Inverte Y
          
          // Garante que as coordenadas est√£o dentro dos limites
          const clampedX = Math.max(0, Math.min(videoWidth, x));
          const clampedY = Math.max(0, Math.min(videoHeight, y));
          
          console.log(`Canto ${index}: 3D(${corner.x.toFixed(2)}, ${corner.y.toFixed(2)}, ${corner.z.toFixed(2)}) -> 2D(${clampedX.toFixed(0)}, ${clampedY.toFixed(0)})`);
          
          return { x: clampedX, y: clampedY };
        });
        
        return corners2D;
      }

      // Extrai a regi√£o do target usando OpenCV (perspective transform)
      function extractTargetRegion(videoFrame, targetCorners2D) {
        if (!opencvReady) {
          console.warn('OpenCV ainda n√£o est√° pronto');
          return null;
        }
        
        try {
          const videoWidth = videoFrame.videoWidth || videoFrame.width;
          const videoHeight = videoFrame.videoHeight || videoFrame.height;
          
          console.log(`Extraindo regi√£o: ${videoWidth}x${videoHeight}`);
          console.log('Cantos:', targetCorners2D);
          
          // Cria um canvas tempor√°rio para o frame do v√≠deo
          const tempCanvas = document.createElement('canvas');
          tempCanvas.width = videoWidth;
          tempCanvas.height = videoHeight;
          const tempCtx = tempCanvas.getContext('2d');
          tempCtx.drawImage(videoFrame, 0, 0);
          
          // Converte para OpenCV Mat
          const src = cv.imread(tempCanvas);
          
          // Ordena os pontos corretamente (superior esquerdo, superior direito, inferior direito, inferior esquerdo)
          // Garante que os pontos est√£o na ordem correta
          const orderedCorners = [...targetCorners2D];
          
          // Define os pontos de origem (cantos do target na imagem)
          const srcPoints = cv.matFromArray(4, 1, cv.CV_32FC2, [
            orderedCorners[0].x, orderedCorners[0].y,
            orderedCorners[1].x, orderedCorners[1].y,
            orderedCorners[2].x, orderedCorners[2].y,
            orderedCorners[3].x, orderedCorners[3].y
          ]);
          
          // Define os pontos de destino (ret√¢ngulo retificado)
          const size = 512; // Tamanho da imagem extra√≠da
          const dstPoints = cv.matFromArray(4, 1, cv.CV_32FC2, [
            0, 0,
            size, 0,
            size, size,
            0, size
          ]);
          
          // Calcula a matriz de transforma√ß√£o perspectiva
          const M = cv.getPerspectiveTransform(srcPoints, dstPoints);
          
          // Aplica a transforma√ß√£o
          const dst = new cv.Mat();
          cv.warpPerspective(src, dst, M, new cv.Size(size, size));
          
          // Converte de volta para canvas
          cv.imshow(canvas, dst);
          
          // Limpa mem√≥ria
          src.delete();
          dst.delete();
          srcPoints.delete();
          dstPoints.delete();
          M.delete();
          
          console.log('‚úÖ Regi√£o extra√≠da com sucesso!');
          return canvas.toDataURL('image/png');
        } catch (error) {
          console.error('‚ùå Erro ao extrair regi√£o do target:', error);
          return null;
        }
      }

      // Extrai regi√£o usando detec√ß√£o autom√°tica de contornos (fallback)
      function extractTargetRegionAuto(videoFrame) {
        if (!opencvReady) {
          return null;
        }
        
        try {
          console.log('üîç Tentando detec√ß√£o autom√°tica de contornos...');
          const videoWidth = videoFrame.videoWidth || videoFrame.width;
          const videoHeight = videoFrame.videoHeight || videoFrame.height;
          
          const tempCanvas = document.createElement('canvas');
          tempCanvas.width = videoWidth;
          tempCanvas.height = videoHeight;
          const tempCtx = tempCanvas.getContext('2d');
          tempCtx.drawImage(videoFrame, 0, 0);
          
          const src = cv.imread(tempCanvas);
          const gray = new cv.Mat();
          cv.cvtColor(src, gray, cv.COLOR_RGBA2GRAY);
          
          // Aplica threshold
          const thresh = new cv.Mat();
          cv.threshold(gray, thresh, 127, 255, cv.THRESH_BINARY);
          
          // Encontra contornos
          const contours = new cv.MatVector();
          const hierarchy = new cv.Mat();
          cv.findContours(thresh, contours, hierarchy, cv.RETR_EXTERNAL, cv.CHAIN_APPROX_SIMPLE);
          
          // Encontra o maior contorno (provavelmente o target)
          let maxArea = 0;
          let maxContour = null;
          for (let i = 0; i < contours.size(); i++) {
            const contour = contours.get(i);
            const area = cv.contourArea(contour);
            if (area > maxArea && area > videoWidth * videoHeight * 0.1) {
              maxArea = area;
              maxContour = contour;
            }
          }
          
          if (maxContour) {
            // Aproxima o contorno para obter os cantos
            const epsilon = 0.02 * cv.arcLength(maxContour, true);
            const approx = new cv.Mat();
            cv.approxPolyDP(maxContour, approx, epsilon, true);
            
            if (approx.rows === 4) {
              // Temos 4 cantos!
              const corners = [];
              for (let i = 0; i < 4; i++) {
                corners.push({
                  x: approx.data32S[i * 2],
                  y: approx.data32S[i * 2 + 1]
                });
              }
              
              // Extrai usando os cantos encontrados
              const extracted = extractTargetRegion(videoFrame, corners);
              
              src.delete();
              gray.delete();
              thresh.delete();
              contours.delete();
              hierarchy.delete();
              approx.delete();
              
              return extracted;
            }
            
            approx.delete();
          }
          
          src.delete();
          gray.delete();
          thresh.delete();
          contours.delete();
          hierarchy.delete();
          
          return null;
        } catch (error) {
          console.error('Erro na detec√ß√£o autom√°tica:', error);
          return null;
        }
      }

      // Processa a imagem extra√≠da do target
      function processExtractedImage(imageData) {
        if (!canvas || !ctx) {
          console.error('Canvas n√£o configurado');
          return null;
        }

        try {
          // Ajusta o tamanho do canvas
          if (imageData.width && imageData.height) {
            canvas.width = imageData.width;
            canvas.height = imageData.height;
          }

          // Desenha a imagem no canvas
          ctx.drawImage(imageData, 0, 0, canvas.width, canvas.height);
        } catch (error) {
          console.error('Erro ao desenhar imagem no canvas:', error);
          return null;
        }
        
        // Obt√©m os dados da imagem
        const imageDataObj = ctx.getImageData(0, 0, canvas.width, canvas.height);
        const data = imageDataObj.data;

        // Processa a imagem para melhorar contraste e preparar para desenho
        // Converte para escala de cinza
        for (let i = 0; i < data.length; i += 4) {
          const r = data[i];
          const g = data[i + 1];
          const b = data[i + 2];
          
          // Converte para escala de cinza
          const gray = 0.299 * r + 0.587 * g + 0.114 * b;
          
          // Aumenta contraste
          let contrast = ((gray / 255) - 0.5) * 2.0 + 0.5;
          contrast = Math.max(0, Math.min(1, contrast));
          
          // Aplica threshold para tornar mais preto e branco
          const threshold = 128;
          const adjusted = gray < threshold ? Math.max(0, gray * 0.7) : Math.min(255, gray * 1.3);
          
          const final = adjusted;
          
          data[i] = final;
          data[i + 1] = final;
          data[i + 2] = final;
        }

        // Aplica o processamento de volta ao canvas
        ctx.putImageData(imageDataObj, 0, 0);
        
        // Aplica filtros
        ctx.filter = 'contrast(1.2) brightness(1.1)';
        ctx.drawImage(canvas, 0, 0);
        ctx.filter = 'none';
        
        return canvas.toDataURL('image/png');
      }

      // Aplica a textura no plano
      function applyTextureToPlane(imageUrl) {
        if (textureCreated) return; // Evita recriar m√∫ltiplas vezes
        
        const planeEl = drawingPlane;
        const mesh = planeEl.getObject3D('mesh');
        
        if (!mesh) {
          // Aguarda o mesh ser criado
          setTimeout(() => applyTextureToPlane(imageUrl), 100);
          return;
        }
        
        // Cria uma imagem a partir da data URL
        const img = new Image();
        img.onload = () => {
          // Cria textura a partir da imagem
          const texture = new THREE.Texture(img);
          texture.flipY = true; // Corrige a invers√£o vertical
          texture.needsUpdate = true;
          
          if (mesh.material) {
            // Se j√° existe material, atualiza
            if (mesh.material.map) {
              mesh.material.map.dispose();
            }
            mesh.material.map = texture;
            mesh.material.needsUpdate = true;
            mesh.material.transparent = true;
            mesh.material.opacity = 1;
          } else {
            // Cria novo material
            mesh.material = new THREE.MeshBasicMaterial({
              map: texture,
              transparent: true,
              opacity: 1
            });
          }
          
          textureCreated = true;
          console.log('Textura aplicada com sucesso!');
        };
        img.onerror = (error) => {
          console.error('Erro ao carregar imagem:', error);
        };
        img.src = imageUrl;
      }

      // Captura frame quando target √© detectado
      function captureTargetFrame() {
        console.log('Tentando capturar frame...', {
          videoElement: !!videoElement,
          canvas: !!canvas,
          ctx: !!ctx,
          textureCreated: textureCreated,
          videoReady: videoElement && videoElement.readyState >= 2
        });
        
        if (!videoElement) {
          console.warn('V√≠deo n√£o dispon√≠vel, tentando encontrar...');
          findVideoElement();
          return;
        }
        
        if (!canvas || !ctx) {
          console.warn('Canvas n√£o configurado');
          setupCanvas();
          return;
        }
        
        if (textureCreated) {
          console.log('Textura j√° foi criada');
          return;
        }
        
        // Verifica se o v√≠deo est√° pronto
        if (videoElement.readyState < 2) {
          console.warn('V√≠deo ainda n√£o est√° pronto, aguardando...');
          videoElement.addEventListener('loadeddata', () => {
            setTimeout(captureTargetFrame, 100);
          }, { once: true });
          return;
        }

        try {
          console.log('Processando imagem do v√≠deo...');
          
          // Tenta capturar do v√≠deo diretamente
          let imageSource = videoElement;
          
          // Se o v√≠deo n√£o estiver dispon√≠vel, tenta alternativas
          if (!imageSource || (imageSource.readyState !== undefined && imageSource.readyState < 2)) {
            console.warn('V√≠deo n√£o est√° pronto, tentando alternativas...');
            
            // Tenta usar o renderer WebGL para capturar
            const renderer = scene.renderer;
            if (renderer && renderer.domElement) {
              try {
                // Tenta ler do canvas WebGL
                const gl = renderer.getContext();
                if (gl) {
                  const width = renderer.domElement.width || 640;
                  const height = renderer.domElement.height || 480;
                  const pixels = new Uint8Array(width * height * 4);
                  gl.readPixels(0, 0, width, height, gl.RGBA, gl.UNSIGNED_BYTE, pixels);
                  
                  // Cria canvas tempor√°rio
                  const tempCanvas = document.createElement('canvas');
                  tempCanvas.width = width;
                  tempCanvas.height = height;
                  const tempCtx = tempCanvas.getContext('2d');
                  const imageData = tempCtx.createImageData(width, height);
                  
                  // Inverte verticalmente (WebGL tem origem no canto inferior esquerdo)
                  for (let y = 0; y < height; y++) {
                    for (let x = 0; x < width; x++) {
                      const srcIndex = ((height - 1 - y) * width + x) * 4;
                      const dstIndex = (y * width + x) * 4;
                      imageData.data[dstIndex] = pixels[srcIndex];
                      imageData.data[dstIndex + 1] = pixels[srcIndex + 1];
                      imageData.data[dstIndex + 2] = pixels[srcIndex + 2];
                      imageData.data[dstIndex + 3] = pixels[srcIndex + 3];
                    }
                  }
                  tempCtx.putImageData(imageData, 0, 0);
                  imageSource = tempCanvas;
                  console.log('‚úÖ Usando WebGL renderer como fonte');
                }
              } catch (e) {
                console.warn('Erro ao capturar do WebGL:', e);
              }
            }
          }
          
          if (!imageSource) {
            console.error('Nenhuma fonte de imagem dispon√≠vel');
            return;
          }
          
          // Tenta extrair apenas a regi√£o do target
          let imageUrl = null;
          
          if (opencvReady) {
            console.log('üîç Tentando extrair regi√£o do target com OpenCV...');
            
            // Obt√©m as coordenadas do target
            const corners3D = getTargetCorners();
            
            if (corners3D && imageSource.videoWidth) {
              console.log('‚úÖ Coordenadas 3D obtidas, projetando para 2D...');
              
              // Converte coordenadas 3D para 2D
              const corners2D = project3DTo2D(
                corners3D, 
                imageSource.videoWidth, 
                imageSource.videoHeight
              );
              
              if (corners2D && corners2D.length === 4) {
                console.log('‚úÖ Coordenadas 2D do target:', corners2D);
                
                // Valida se as coordenadas s√£o v√°lidas
                const valid = corners2D.every(c => 
                  c.x >= 0 && c.x <= imageSource.videoWidth && 
                  c.y >= 0 && c.y <= imageSource.videoHeight
                );
                
                if (valid) {
                  // Extrai a regi√£o do target
                  console.log('üìê Extraindo regi√£o do target...');
                  const extractedImageUrl = extractTargetRegion(imageSource, corners2D);
                  
                  if (extractedImageUrl) {
                    console.log('‚úÖ Regi√£o extra√≠da! Processando imagem...');
                    // Processa a imagem extra√≠da
                    const img = new Image();
                    img.onload = () => {
                      const processedUrl = processExtractedImage(img);
                      if (processedUrl) {
                        console.log('‚úÖ Regi√£o do target extra√≠da e processada!');
                        applyTextureToPlane(processedUrl);
                        return; // Sucesso!
                      }
                    };
                    img.onerror = () => {
                      console.error('Erro ao carregar imagem extra√≠da');
                    };
                    img.src = extractedImageUrl;
                    return; // Sai da fun√ß√£o, o processamento continua no onload
                  } else {
                    console.error('‚ùå Falha ao extrair regi√£o do target');
                  }
                } else {
                  console.warn('‚ö†Ô∏è Coordenadas inv√°lidas, tentando detec√ß√£o autom√°tica...');
                  // Tenta detec√ß√£o autom√°tica de contornos
                  const autoExtracted = extractTargetRegionAuto(imageSource);
                  if (autoExtracted) {
                    const img = new Image();
                    img.onload = () => {
                      const processedUrl = processExtractedImage(img);
                      if (processedUrl) {
                        console.log('‚úÖ Regi√£o extra√≠da via detec√ß√£o autom√°tica!');
                        applyTextureToPlane(processedUrl);
                        return;
                      }
                    };
                    img.src = autoExtracted;
                    return;
                  }
                }
              } else {
                console.warn('‚ö†Ô∏è N√£o foi poss√≠vel projetar coordenadas 3D para 2D');
              }
            } else {
              console.warn('‚ö†Ô∏è N√£o foi poss√≠vel obter coordenadas do target ou dimens√µes do v√≠deo');
            }
            
            console.warn('‚ö†Ô∏è N√£o foi poss√≠vel extrair regi√£o do target, usando imagem completa...');
          } else {
            console.warn('‚ö†Ô∏è OpenCV n√£o est√° pronto ainda');
          }
          
          // Fallback: processa a imagem completa se n√£o conseguir extrair a regi√£o
          console.log('üì∑ Processando imagem completa como fallback...');
          imageUrl = processExtractedImage(imageSource);
          
          if (imageUrl) {
            console.log('‚úÖ Imagem processada com sucesso, aplicando textura...');
            applyTextureToPlane(imageUrl);
          } else {
            console.error('‚ùå Falha ao processar imagem');
          }
        } catch (error) {
          console.error('Erro ao capturar frame:', error);
          console.error('Stack:', error.stack);
        }
      }

      // Escuta eventos do MindAR
      targetEntity.addEventListener('targetFound', () => {
        isTargetDetected = true;
        console.log('=== TARGET DETECTADO ===');
        console.log('Estado:', {
          videoElement: !!videoElement,
          videoReady: videoElement ? videoElement.readyState : 'N/A',
          canvas: !!canvas,
          textureCreated: textureCreated
        });
        
        // Se o v√≠deo ainda n√£o foi encontrado, tenta encontrar agora
        if (!videoElement) {
          findVideoElement();
        }
        
        // Aguarda um pouco para garantir que a c√¢mera est√° est√°vel
        setTimeout(() => {
          captureTargetFrame();
        }, 300);
      });

      targetEntity.addEventListener('targetLost', () => {
        isTargetDetected = false;
        console.log('Target perdido');
      });

      // Captura cont√≠nua enquanto target est√° vis√≠vel (com mais tentativas)
      setInterval(() => {
        if (isTargetDetected && !textureCreated) {
          if (!videoElement) {
            findVideoElement();
          }
          if (videoElement && videoElement.readyState >= 2) {
            captureTargetFrame();
          }
        }
      }, 500);
      
      // Log inicial
      console.log('Sistema de captura inicializado');
    </script>
  </body>
</html>